/*!
Waypoints - 4.0.1
Copyright Ã‚Â© 2011-2016 Caleb Troughton
Licensed under the MIT license.
https://github.com/imakewebthings/waypoints/blob/master/licenses.txt
*/

(function () {
    "use strict";

    let waypointCount = 0;
    const waypoints = {};

    function Waypoint(options) {
        if (!options) throw new Error("No options passed to Waypoint constructor");
        if (!options.element) throw new Error("No element option passed to Waypoint constructor");
        if (!options.handler) throw new Error("No handler option passed to Waypoint constructor");

        this.key = `waypoint-${waypointCount}`;
        this.options = Object.assign({}, Waypoint.defaults, options);
        this.element = this.options.element;
        this.adapter = new Waypoint.Adapter(this.element);
        this.callback = options.handler;
        this.axis = this.options.horizontal ? "horizontal" : "vertical";
        this.enabled = this.options.enabled;
        this.triggerPoint = null;
        this.group = Waypoint.Group.findOrCreate({
            name: this.options.group,
            axis: this.axis
        });
        this.context = Waypoint.Context.findOrCreateByElement(this.options.context);

        if (Waypoint.offsetAliases[this.options.offset]) {
            this.options.offset = Waypoint.offsetAliases[this.options.offset];
        }

        this.group.add(this);
        this.context.add(this);
        waypoints[this.key] = this;
        waypointCount++;
    }

    Waypoint.prototype.queueTrigger = function (direction) {
        this.group.queueTrigger(this, direction);
    };

    Waypoint.prototype.trigger = function (direction) {
        if (this.enabled && this.callback) {
            this.callback.apply(this, direction);
        }
    };

    Waypoint.prototype.destroy = function () {
        this.context.remove(this);
        this.group.remove(this);
        delete waypoints[this.key];
    };

    Waypoint.prototype.disable = function () {
        this.enabled = false;
        return this;
    };

    Waypoint.prototype.enable = function () {
        this.context.refresh();
        this.enabled = true;
        return this;
    };

    Waypoint.prototype.next = function () {
        return this.group.next(this);
    };

    Waypoint.prototype.previous = function () {
        return this.group.previous(this);
    };

    Waypoint.invokeAll = function (method) {
        const waypointArray = Object.values(waypoints);
        waypointArray.forEach(waypoint => waypoint[method]());
    };

    Waypoint.destroyAll = function () {
        Waypoint.invokeAll("destroy");
    };

    Waypoint.disableAll = function () {
        Waypoint.invokeAll("disable");
    };

    Waypoint.enableAll = function () {
        Waypoint.Context.refreshAll();
        Object.values(waypoints).forEach(waypoint => waypoint.enabled = true);
    };

    Waypoint.refreshAll = function () {
        Waypoint.Context.refreshAll();
    };

    Waypoint.viewportHeight = function () {
        return window.innerHeight || document.documentElement.clientHeight;
    };

    Waypoint.viewportWidth = function () {
        return document.documentElement.clientWidth;
    };

    Waypoint.adapters = [];
    Waypoint.defaults = {
        context: window,
        continuous: true,
        enabled: true,
        group: "default",
        horizontal: false,
        offset: 0
    };

    Waypoint.offsetAliases = {
        "bottom-in-view": function () {
            return this.context.innerHeight() - this.adapter.outerHeight();
        },
        "right-in-view": function () {
            return this.context.innerWidth() - this.adapter.outerWidth();
        }
    };

    window.Waypoint = Waypoint;
})();

(function () {
    "use strict";

    let contextCount = 0;
    const contexts = {};

    function Context(element) {
        this.element = element;
        this.Adapter = Waypoint.Adapter;
        this.adapter = new this.Adapter(element);
        this.key = `waypoint-context-${contextCount}`;
        this.oldScroll = {
            x: this.adapter.scrollLeft(),
            y: this.adapter.scrollTop()
        };
        this.waypoints = {
            vertical: {},
            horizontal: {}
        };

        element.waypointContextKey = this.key;
        contexts[element.waypointContextKey] = this;
        contextCount++;

        if (!Waypoint.windowContext) {
            Waypoint.windowContext = new Context(window);
        }

        this.createThrottledHandlers();
    }

    Context.prototype.add = function (waypoint) {
        const axis = waypoint.options.horizontal ? "horizontal" : "vertical";
        this.waypoints[axis][waypoint.key] = waypoint;
        this.refresh();
    };

    Context.prototype.checkEmpty = function () {
        const isHorizontalEmpty = Waypoint.Adapter.isEmptyObject(this.waypoints.horizontal);
        const isVerticalEmpty = Waypoint.Adapter.isEmptyObject(this.waypoints.vertical);
        const isWindow = this.element === this.element.window;

        if (isHorizontalEmpty && isVerticalEmpty && !isWindow) {
            this.adapter.off(".waypoints");
            delete contexts[this.key];
        }
    };

    Context.prototype.createThrottledHandlers = function () {
        const self = this;
        this.adapter.on("scroll.waypoints", function () {
            if (!self.didScroll) {
                self.didScroll = true;
                Waypoint.requestAnimationFrame(() => self.handleScroll());
            }
        });

        this.adapter.on("resize.waypoints", function () {
            if (!self.didResize) {
                self.didResize = true;
                Waypoint.requestAnimationFrame(() => self.handleResize());
            }
        });
    };

    Context.prototype.handleScroll = function () {
        // logic for handling scroll
    };

    Context.prototype.handleResize = function () {
        Waypoint.Context.refreshAll();
    };

    Context.prototype.refresh = function () {
        // logic for refreshing waypoints
    };

    Context.findOrCreateByElement = function (element) {
        return contexts[element.waypointContextKey] || new Context(element);
    };

    Context.refreshAll = function () {
        Object.values(contexts).forEach(context => context.refresh());
    };

    Waypoint.Context = Context;
})();
